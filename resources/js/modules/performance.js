// ============================================
// PERFORMANCE OPTIMIZATION MODULE
// ============================================

export class PerformanceOptimizer {
  constructor() {
    this.images = new Set();
    this.observers = new Map();
    this.init();\n  }\n\n  init() {\n    this.setupLazyLoading();\n    this.setupImageOptimization();\n    this.setupIntersectionObserver();\n    this.setupServiceWorker();\n  }\n\n  /**\n   * Lazy loading for images\n   */\n  setupLazyLoading() {\n    const imageObserver = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const img = entry.target;\n          \n          // Load the actual image\n          if (img.dataset.src) {\n            img.src = img.dataset.src;\n            img.removeAttribute('data-src');\n          }\n          \n          if (img.dataset.srcset) {\n            img.srcset = img.dataset.srcset;\n            img.removeAttribute('data-srcset');\n          }\n          \n          img.classList.remove('lazy-loading');\n          img.classList.add('lazy-loaded');\n          \n          observer.unobserve(img);\n          this.images.delete(img);\n        }\n      });\n    }, {\n      rootMargin: '50px 0px',\n      threshold: 0.01\n    });\n\n    // Observe all lazy images\n    document.querySelectorAll('img[data-src]').forEach(img => {\n      img.classList.add('lazy-loading');\n      imageObserver.observe(img);\n      this.images.add(img);\n    });\n\n    this.observers.set('images', imageObserver);\n  }\n\n  /**\n   * Image optimization and WebP support\n   */\n  setupImageOptimization() {\n    const supportsWebP = this.checkWebPSupport();\n    \n    if (supportsWebP) {\n      document.querySelectorAll('img[data-webp]').forEach(img => {\n        img.dataset.src = img.dataset.webp;\n      });\n    }\n  }\n\n  /**\n   * Check WebP support\n   */\n  checkWebPSupport() {\n    const canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;\n  }\n\n  /**\n   * Generic intersection observer for animations\n   */\n  setupIntersectionObserver() {\n    const animationObserver = new IntersectionObserver((entries) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const element = entry.target;\n          \n          // Add animation classes\n          if (element.dataset.animate) {\n            element.classList.add(element.dataset.animate);\n          }\n          \n          // Trigger custom animation events\n          element.dispatchEvent(new CustomEvent('elementVisible', {\n            detail: { element }\n          }));\n        }\n      });\n    }, {\n      threshold: 0.1\n    });\n\n    // Observe elements with animation data\n    document.querySelectorAll('[data-animate]').forEach(el => {\n      animationObserver.observe(el);\n    });\n\n    this.observers.set('animations', animationObserver);\n  }\n\n  /**\n   * Register service worker for caching\n   */\n  async setupServiceWorker() {\n    if ('serviceWorker' in navigator) {\n      try {\n        const registration = await navigator.serviceWorker.register('/sw.js');\n        console.log('Service Worker registered:', registration);\n      } catch (error) {\n        console.log('Service Worker registration failed:', error);\n      }\n    }\n  }\n\n  /**\n   * Add new images to lazy loading\n   */\n  addLazyImages(container = document) {\n    const imageObserver = this.observers.get('images');\n    if (!imageObserver) return;\n\n    container.querySelectorAll('img[data-src]:not(.lazy-loading)').forEach(img => {\n      img.classList.add('lazy-loading');\n      imageObserver.observe(img);\n      this.images.add(img);\n    });\n  }\n\n  /**\n   * Preload critical images\n   */\n  preloadCriticalImages(urls) {\n    urls.forEach(url => {\n      const link = document.createElement('link');\n      link.rel = 'preload';\n      link.as = 'image';\n      link.href = url;\n      document.head.appendChild(link);\n    });\n  }\n\n  /**\n   * Cleanup observers\n   */\n  destroy() {\n    this.observers.forEach(observer => observer.disconnect());\n    this.observers.clear();\n    this.images.clear();\n  }\n}\n\n// Resource loading optimizer\nexport class ResourceLoader {\n  constructor() {\n    this.loadedResources = new Set();\n    this.pendingResources = new Map();\n  }\n\n  /**\n   * Load CSS dynamically\n   */\n  async loadCSS(href, id = null) {\n    if (this.loadedResources.has(href)) {\n      return Promise.resolve();\n    }\n\n    if (this.pendingResources.has(href)) {\n      return this.pendingResources.get(href);\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = href;\n      if (id) link.id = id;\n      \n      link.onload = () => {\n        this.loadedResources.add(href);\n        this.pendingResources.delete(href);\n        resolve();\n      };\n      \n      link.onerror = () => {\n        this.pendingResources.delete(href);\n        reject(new Error(`Failed to load CSS: ${href}`));\n      };\n      \n      document.head.appendChild(link);\n    });\n\n    this.pendingResources.set(href, promise);\n    return promise;\n  }\n\n  /**\n   * Load JavaScript dynamically\n   */\n  async loadJS(src, id = null) {\n    if (this.loadedResources.has(src)) {\n      return Promise.resolve();\n    }\n\n    if (this.pendingResources.has(src)) {\n      return this.pendingResources.get(src);\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = src;\n      script.async = true;\n      if (id) script.id = id;\n      \n      script.onload = () => {\n        this.loadedResources.add(src);\n        this.pendingResources.delete(src);\n        resolve();\n      };\n      \n      script.onerror = () => {\n        this.pendingResources.delete(src);\n        reject(new Error(`Failed to load JS: ${src}`));\n      };\n      \n      document.head.appendChild(script);\n    });\n\n    this.pendingResources.set(src, promise);\n    return promise;\n  }\n\n  /**\n   * Preload resources\n   */\n  preload(urls, as = 'script') {\n    urls.forEach(url => {\n      const link = document.createElement('link');\n      link.rel = 'preload';\n      link.as = as;\n      link.href = url;\n      document.head.appendChild(link);\n    });\n  }\n}\n\n// Initialize performance optimizations\nexport function initPerformanceOptimizations() {\n  const optimizer = new PerformanceOptimizer();\n  const resourceLoader = new ResourceLoader();\n\n  // Make available globally\n  window.CerfaosPerformance = {\n    optimizer,\n    resourceLoader\n  };\n\n  // Auto-optimize new content\n  const contentObserver = new MutationObserver((mutations) => {\n    mutations.forEach((mutation) => {\n      if (mutation.type === 'childList') {\n        mutation.addedNodes.forEach((node) => {\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            optimizer.addLazyImages(node);\n          }\n        });\n      }\n    });\n  });\n\n  contentObserver.observe(document.body, {\n    childList: true,\n    subtree: true\n  });\n\n  return { optimizer, resourceLoader };\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initPerformanceOptimizations);\n} else {\n  initPerformanceOptimizations();\n}